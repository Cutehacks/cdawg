// Copyright 2015 Cutehacks AS. All rights reserved.
// License can be found in the LICENSE file.

package main

import (
	"fmt"
	"os"
	"sort"
	"strconv"
	"io/ioutil"
	"encoding/json"
)

type Node struct {
	value string
	pattern string
	key uint8
	nodes map[uint8] *Node
}

func NewNode() *Node {
	return &Node{
		nodes: make(map[uint8] *Node),
	}
}

func BuildGraph(mapping map[string]string) (*Node) {

	var keys []string
	for k := range mapping {
		keys = append(keys, k)
	}
	sort.Strings(keys)

	root := NewNode()
	for _, k := range keys {
		var tree = root
		for i := 0; i < len(k); i++ {
			key := k[i]
			sub, ok := tree.nodes[key];
			if !ok {
				sub = NewNode()
				tree.nodes[key] = sub
			}
			sub.key = key
			tree = sub
		}
		tree.value = mapping[k]
		tree.pattern = k
	}
	return root
}

func WriteSwitch(root *Node, depth int, indent string)  {

	indent += "  "

	if len(root.nodes) == 0 {
		fmt.Println(indent + "return QPair<int, int>(0, 0); // no deeper pattern")
		return
	}

	if (depth == 0) {
		fmt.Println(indent + "if (i >= length)")
		fmt.Println(indent + "  return QPair<int, int>(0, 0);")
		fmt.Println(indent + "switch (text[i].unicode()) {")
	} else {
		fmt.Println(indent + "if (i + " + strconv.Itoa(depth) + " >= length)")
		fmt.Println(indent + "  return QPair<int, int>(0, 0);")
		fmt.Println(indent + "switch (text[i + " + strconv.Itoa(depth) + "].unicode()) {")
	}

	for key := range root.nodes {
		sub, _ := root.nodes[key]
		if len(sub.value) > 0 { // we have a match
			fmt.Println(indent + "  case " + strconv.Itoa(int(key)) + ":")
			fmt.Println(indent + "    if (i + " + strconv.Itoa(depth + 1) + " >= length || text[i + " + strconv.Itoa(depth + 1) + "].isSpace() || text[i + " + strconv.Itoa(depth + 1) + "].isPunct())")
			fmt.Println(indent + "      return QPair<int, int>(0x" + sub.value + ", " + strconv.Itoa(depth + 1 ) + ");" + " // " + sub.pattern + " found")
			WriteSwitch(sub, depth + 1, indent + "  ")

		} else { // continue searching
			fmt.Println(indent + "  case " + strconv.Itoa(int(key)) + ": ")
			WriteSwitch(sub, depth + 1, indent + "  ")
		}
	}
	fmt.Println(indent + "  default: return QPair<int, int>(0, 0);");
	fmt.Println(indent + "}")
}

func WriteFunc(root *Node) {
	fmt.Println("// Generated by the CDAWG tool by Cutehacks AS.")
	fmt.Println("// For more info go to http://www.cutehacks.com\n")
	fmt.Println("#include <QPair>")
	fmt.Println("#include <QString>\n")
	fmt.Println("QPair<int, int> cdawg_match(const QString &text, int length, int i)\n{")
	WriteSwitch(root, 0, "")
	fmt.Println("  return QPair<int, int>(0, 0);")
	fmt.Println("}")
}

func main() {

	data, err := ioutil.ReadFile(os.Args[1])
	if err != nil {
		fmt.Println(err)
		return
	}

	var mapping map[string]string//interface{}
	err = json.Unmarshal([]byte(data), &mapping)
	if err != nil {
		fmt.Println(err)
		return
	}

	WriteFunc(BuildGraph(mapping))
}